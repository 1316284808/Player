# 2025-11-07 视频全屏播放问题解决方案总结

## 问题背景

在开发视频播放器过程中，需要实现全屏播放功能，要求支持悬浮控制栏，在全屏状态下能够显示播放控制界面。

## 尝试的三种方案

### 方案一：独立窗体实现全屏（❌ 被否定）

**实施思路：**
- 创建新的全屏窗口
- 将视频播放器内容复制到新窗口
- 实现全屏播放体验

**遇到的问题：**
1. **MediaPlayer实例共享问题**
   - 两个窗口需要共享同一个MediaPlayer实例
   - 尝试直接共享MediaPlayer会导致资源冲突和状态不一致
   - 无法在窗口间无缝切换播放器状态

2. **VideoView实例维护问题**
   - 需要维护两个VideoView实例
   - 切换时可能出现视频闪烁或黑屏
   - 内存占用增加，性能下降

**结论：** 由于技术复杂度高且稳定性差，此方案被否定。

### 方案二：VLC原生全屏（❌ 无法实施）

**实施思路：**
- 直接调用VLC播放器的原生全屏API
- 利用VLC内置的全屏功能

**遇到的问题：**
1. **平台兼容性问题**
   -  LibVLCSharp 不支持直接调用 VLC 的“原生全屏”（即由 libvlc 内部创建全屏窗口）。
   -  libvlc_set_fullscreen() 等 C API 在 Windows 上通常依赖于 Win32 窗口句柄，而 WPF 的 VideoView 是通过 HwndHost封装的，在 .NET Core / .NET 5+ 中该机制受限，且与 WPF 渲染模型不兼容。
   -  官方示例和社区实践均不推荐使用原生全屏，而是由应用层自己实现全屏。


**结论：** 由于平台兼容性问题，此方案无法实施。

### 方案三：伪全屏（✅ 实测可行，完成度90%）

**实施思路：**
- 保持主窗口不变
- 调整窗口大小和位置实现全屏效果
- 动态调整界面元素样式

**实现细节：**

#### 1. 窗口调整
```csharp
// 保存原始窗口状态
_originalWindowState = WindowState;
_originalWindowStyle = WindowStyle;

// 进入全屏
WindowState = WindowState.Maximized;
WindowStyle = WindowStyle.None;
WindowState = WindowState.Maximized;
```

#### 2. 悬浮控制栏实现
- 使用透明背景和鼠标事件处理
- 控制栏仅在鼠标移动时显示
- 支持播放、暂停、进度调整等操作

#### 3. VideoPlayer父元素样式调整
```csharp
// 全屏时调整父元素样式
private void AdjustVideoPlayerParentStyles(bool isFullscreen)
{
    if (isFullscreen)
    {
        // 移除圆角、边距，让视频占满屏幕
        OuterBorder.CornerRadius = new CornerRadius(0);
        OuterBorder.Margin = new Thickness(0);
        OuterBorder.Padding = new Thickness(0);
        InnerBorder.CornerRadius = new CornerRadius(0);
        InnerBorder.BorderThickness = new Thickness(0);
    }
    else
    {
        // 恢复正常状态样式
        OuterBorder.CornerRadius = new CornerRadius(8);
        OuterBorder.Margin = new Thickness(10);
        OuterBorder.Padding = new Thickness(5);
        InnerBorder.CornerRadius = new CornerRadius(8);
        InnerBorder.BorderThickness = new Thickness(2);
    }
}
```

#### 4. 消息机制实现状态同步
- 使用IMessengerService进行组件间通信
- 全屏状态变化时通知所有相关组件
- 确保界面元素状态一致

**技术亮点：**
1. **消息驱动架构**：使用消息服务实现组件间解耦
2. **样式动态调整**：根据全屏状态实时调整UI元素
3. **用户体验优化**：悬浮控制栏提供良好的交互体验

**当前完成度：90%**
- ✅ 全屏/退出全屏功能正常
- ✅ 悬浮控制栏实现
- ✅ VideoPlayer父元素样式动态调整
- ⚠️ 悬浮控制栏的隐藏和显现需要进一步查找资料

## 关键代码实现

### MiddleControl.xaml 关键修改
```xml
<!-- 外层Border，添加名称 -->
<Border x:Name="OuterBorder" CornerRadius="8" Grid.Row="0" Background="black" 
        Padding="5" Margin="10" Opacity="0.95" ClipToBounds="True">
    
    <!-- 内层Border，添加名称 -->
    <Border x:Name="InnerBorder" CornerRadius="8" Background="black" Padding="0" 
            ClipToBounds="True" BorderBrush="Black" BorderThickness="2" Panel.ZIndex="1">
        <!-- VideoPlayer内容 -->
    </Border>
</Border>
```

### MiddleControl.xaml.cs 全屏处理逻辑
```csharp
// 订阅全屏状态变化消息
_messengerService.Register<FullscreenChangedMessage>(this, OnFullscreenChangedMessage);

private void OnFullscreenChangedMessage(object recipient, FullscreenChangedMessage message)
{
    Dispatcher.Invoke(() => AdjustVideoPlayerParentStyles(message.Value));
}
```



